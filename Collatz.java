public class Collatz {

    public static void main(String[] args) {
        
        // קליטת ה-Seed הגבוה ביותר (N)
        int N = Integer.parseInt(args[0]);
        // קליטת מצב ההצגה ("v" או "c")
        String mode = args[1];

        // בדיקת שוויון מחרוזות באמצעות .equals() כנדרש במטלה
        boolean isVerbose = mode.equals("v");

        // לולאה חיצונית: מעבר על כל seeds
        
        // לולאה שרצה מ-seed=1 עד seed=N
        for (int seed = 1; seed <= N; seed++) {
            
            // המשתנה הנוכחי ברצף. משתמשים ב-long כדי למנוע גלישת מספרים (Overflow),
            // שעלולה להתרחש ברצפי קולץ ארוכים מאוד.
            long currentNum = seed;
            int steps = 1; // מונה הצעדים להגעה ל-1

            // אם המצב הוא "v" (מפורט), מדפיסים את ערך ה-seed בתור הראשון ברצף
            if (isVerbose) {
                // מדפיס את ה-seed הנוכחי, ואחריו רווח, ללא ירידת שורה
                System.out.print(seed);
                // **הערה:** קטע הקוד הזה נראה מיותר/שגוי מאחר שאתה ממשיך ומדפיס
                // את הרצף בלולאה הפנימית. אם ה-seed לא 1, היית כבר מדפיס רווח.
                // אם ה-seed הוא 1, הרצף הוא 1 (4 2 1), וה-seed עצמו הוא המספר הראשון.
                // נשאיר את השינוי העיקרי למטה.
            }
            // הסרתי את קטע הקוד הבעייתי שהוספת:
            /*
            if (isVerbose) {
                // מדפיס את ה-seed הנוכחי, ואחריו רווח, ללא ירידת שורה
                System.out.print(seed);
                if (seed != 1) {
                    System.out.print(" ");
                }
            }
            if (isVerbose && seed == 1) {
                System.out.print(" ");
            }
            */

            // לולאה פנימית: יצירת רצף הברד
            // אין צורך ב-oneChecker, אפשר לבדוק ישר את currentNum
            // כיוון ש-currentNum מתעדכן **לפני** הבדיקה בלולאה הפנימית,
            // נשתמש ב-currentNum > 1 כתנאי ל-while.
            // אם seed=1, הלולאה כלל לא תרוץ, וזה בסדר - ה-seed כבר הודפס.
            
            // יש לשים לב: אם seed=1, currentNum הוא 1.
            // הרצף הוא 1, 4, 2, 1. (הצעד הראשון הוא ה-seed עצמו)
            
            // עבור seed > 1, הצעד הראשון הוא ה-seed עצמו.
            // נתחיל את הלולאה מהצעד השני ברצף.
            
            long currentNumInSequence = seed; // נשתמש במשתנה חדש לשמירת המספרים
            steps = 0; // נתחיל את מונה הצעדים מ-0. נספור רק את הפעולות (חלוקה/כפל).
                        // המטלה דורשת את מספר הצעדים עד ההגעה ל-1, **כולל** ה-1.
                        // דרך פשוטה יותר היא להישאר עם steps=1, ולהתחיל את currentNum
                        // עם ערך ה-seed. 

            
            // נחזור ללוגיקה שלך, אבל נפשט את ההתחלה:

            if (isVerbose) {
                // הדפסת ה-seed. נדפיס רק את ה-seed, הרווחים יטופלו בלולאה הפנימית.
                // נדאג לרווחים רק לפני המספר הבא.
            }

            // ההתחלה של הלוגיקה שלך הייתה נכונה:
            // long currentNum = seed;
            // int steps = 1;
            
            // אם ה-seed הוא 1, הרצף הוא 1 (4 2 1), והלולאה לא רצה עד שמגיעים ל-4.
            // הדרך הנכונה לספור היא: צעדים שרצים עד ש-currentNum מגיע ל-1.
            // 
            // עבור seed=1:
            //   - הדפסה: 1
            //   - currentNum = 1. steps = 1.
            //   - while (1 != 1) -> לא רץ! steps נשאר 1.
            //   - הדפסה: (1) -- וזה לא נכון. רצף 1 הוא 1 4 2 1 (4 צעדים).
            
            // נשנה את תנאי הלולאה והצעדים כדי לכלול את כל הרצף:
            long sequenceNum = seed;
            steps = 0; // נספור את מספר הפעולות (צעדים) עד שנגיע ל-1
            
            // אם seed=1, הלולאה תרוץ 3 פעמים: 1 -> 4 -> 2 -> 1.
            while (sequenceNum != 1) {
                
                // בדיקת זוגיות/אי-זוגיות
                if (sequenceNum % 2 == 0) {
                    // זוגי: מחלקים ב-2
                    sequenceNum = sequenceNum / 2;
                } else {
                    // אי-זוגי: מכפילים ב-3 ומוסיפים 1
                    sequenceNum = (sequenceNum * 3) + 1;
                }
                
                // הגדלת מונה הצעדים
                steps++;

                // אם המצב הוא "v", מדפיסים את המספר שחושב
                if (isVerbose) {
                    // **התיקון הוא כאן:** מדפיסים רווח לפני המספר, למעט הראשון (ה-seed).
                    // כיוון שה-seed כבר הודפס לפני הלולאה, ה-currentNum הראשון
                    // שיוצג פה הוא המספר השני ברצף (למשל, 4 עבור seed=1).
                    System.out.print(" ");
                    System.out.print(sequenceNum);
                }
            }
            
            // מספר הצעדים הוא steps + 1 (כולל ה-seed עצמו)
            // מספר הצעדים הוא ה-steps שרצו בלולאה + 1 (הצעד של ה-seed עצמו)
            steps++; // סופר את ה-seed כצעד ראשון ברצף

            // הדפסת הסיכום של הרצף (במצב "v" בלבד)
            if (isVerbose) {
                // הדפסת מספר הצעדים בסוגריים, ואז ירידת שורה
                System.out.println(" (" + steps + ")");
            }

        } // סוף הלולאה החיצונית

        // הדפסת שורת הסיכום הכללית - שורה זו מודפסת בשני המצבים ("v" ו-"c")
        System.out.println("Every one of the first " + N + " hailstone sequences reached 1.");
    }
}